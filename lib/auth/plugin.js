/**
 * src/auth/plugin.ts — OpenClaw FIM Auth Plugin Generator
 *
 * Generates the ~/.openclaw/plugins/intentguard-fim-auth.js plugin file
 * that hooks into OpenClaw's onBeforeToolCall lifecycle to enforce
 * geometric permission checks.
 *
 * ARCHITECTURE:
 *   - This module exports plugin generation utilities
 *   - The generated plugin is a standalone JS module loaded by OpenClaw
 *   - Plugin reads identity from geometric.ts computations
 *   - Enforces tensor overlap + sovereignty thresholds
 *
 * USAGE:
 *   import { generatePluginCode, installPlugin } from './auth/plugin.ts';
 *   installPlugin(pluginDir, identity); // Writes intentguard-fim-auth.js
 */
import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';
import { DEFAULT_REQUIREMENTS } from './geometric.js';
// ─── Plugin Code Generation ─────────────────────────────────────────
/**
 * Generate the OpenClaw plugin code as a standalone JS module.
 *
 * The plugin is written in plain JavaScript (not TypeScript) because
 * OpenClaw loads it via require() without transpilation.
 *
 * @param identity - Current user identity vector from trust-debt pipeline
 * @param requirements - Action requirements map (defaults to DEFAULT_REQUIREMENTS)
 * @param threshold - Overlap threshold for permission (default 0.8)
 * @returns JavaScript source code string
 */
export function generatePluginCode(identity, requirements = DEFAULT_REQUIREMENTS, threshold = 0.8) {
    // Convert requirements array to object map
    const requirementsMap = Object.fromEntries(requirements.map(r => [r.toolName, { requiredScores: r.requiredScores, minSovereignty: r.minSovereignty }]));
    // Extract category scores as plain object
    const categoryScores = Object.fromEntries(Object.entries(identity.categoryScores).map(([k, v]) => [k, v ?? 0.7]));
    return `/**
 * IntentGuard FIM Auth Plugin — Auto-generated by src/auth/plugin.ts
 * Hooks into OpenClaw onBeforeToolCall for geometric permission checks.
 *
 * Identity: ${identity.userId}
 * Sovereignty: ${identity.sovereigntyScore.toFixed(3)}
 * Last Updated: ${identity.lastUpdated}
 * Threshold: ${threshold}
 */

// ─── Action Requirements Map ────────────────────────────────────────

const ACTION_REQUIREMENTS = ${JSON.stringify(requirementsMap, null, 2)};

// ─── Identity State ─────────────────────────────────────────────────

let currentSovereignty = ${identity.sovereigntyScore};
let identityScores = ${JSON.stringify(categoryScores, null, 2)};

// ─── Geometric Overlap Computation ──────────────────────────────────

/**
 * Compute tensor overlap between identity and requirement.
 * Returns proportion of required categories meeting minimums (0.0-1.0).
 */
function computeOverlap(identityScores, requirement) {
  if (!requirement || !requirement.requiredScores) return 1.0;

  const entries = Object.entries(requirement.requiredScores);
  if (entries.length === 0) return 1.0;

  let met = 0;
  for (const [category, minScore] of entries) {
    const score = identityScores[category] ?? 0;
    if (score >= minScore) met++;
  }

  return met / entries.length;
}

// ─── Plugin Lifecycle Hooks ─────────────────────────────────────────

/**
 * Called by OpenClaw to update plugin state.
 * IntentGuard sends sovereignty updates via WebSocket parasite hook.
 */
exports.onConfigUpdate = function(update) {
  if (update.sovereignty !== undefined) {
    currentSovereignty = update.sovereignty;
    console.log('[FIM] Sovereignty updated:', currentSovereignty.toFixed(3));
  }
  if (update.identityScores) {
    identityScores = update.identityScores;
    console.log('[FIM] Identity scores updated');
  }
};

/**
 * Called before every tool execution.
 * Enforces geometric permission: overlap >= ${threshold} && sovereignty >= minSovereignty.
 */
exports.onBeforeToolCall = async function(context) {
  const { tool, params } = context;

  // Lookup requirement for this tool
  const requirement = ACTION_REQUIREMENTS[tool];

  // No requirement = allow (fail-open for unknown tools)
  if (!requirement) {
    return { allowed: true, params };
  }

  // Compute geometric overlap
  const overlap = computeOverlap(identityScores, requirement);

  // Check both overlap threshold and sovereignty minimum
  const overlapMet = overlap >= ${threshold};
  const sovereigntyMet = currentSovereignty >= requirement.minSovereignty;

  if (overlapMet && sovereigntyMet) {
    // Permission granted
    return { allowed: true, params };
  } else {
    // Permission denied
    const reason = [
      'FIM permission denied:',
      \`overlap=\${overlap.toFixed(3)} (need >= ${threshold})\`,
      \`sovereignty=\${currentSovereignty.toFixed(3)} (need >= \${requirement.minSovereignty})\`,
    ].join(' ');

    console.log('[FIM] DENIED:', tool, reason);
    return { allowed: false, reason };
  }
};

// ─── Plugin Metadata ────────────────────────────────────────────────

exports.pluginName = 'intentguard-fim-auth';
exports.pluginVersion = '2.1.0';
`;
}
// ─── Plugin Installation ────────────────────────────────────────────
/**
 * Install the FIM auth plugin into OpenClaw's plugins directory.
 *
 * Creates ~/.openclaw/plugins/ if needed, generates plugin code,
 * and writes intentguard-fim-auth.js.
 *
 * @param pluginDir - Path to OpenClaw plugins directory (default ~/.openclaw/plugins)
 * @param identity - Current identity vector from trust-debt pipeline
 * @param requirements - Optional custom requirements (defaults to DEFAULT_REQUIREMENTS)
 * @param threshold - Optional custom threshold (default 0.8)
 * @returns Path to installed plugin file
 */
export function installPlugin(pluginDir, identity, requirements, threshold) {
    // Ensure plugin directory exists
    if (!existsSync(pluginDir)) {
        mkdirSync(pluginDir, { recursive: true });
    }
    // Generate plugin code
    const code = generatePluginCode(identity, requirements, threshold);
    // Write plugin file
    const pluginPath = join(pluginDir, 'intentguard-fim-auth.js');
    writeFileSync(pluginPath, code, 'utf-8');
    return pluginPath;
}
/**
 * Get the default OpenClaw plugin directory path.
 * Returns ~/.openclaw/plugins
 */
export function getDefaultPluginDir() {
    const home = process.env.HOME ?? '/tmp';
    return join(home, '.openclaw', 'plugins');
}
//# sourceMappingURL=plugin.js.map